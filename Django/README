启动项目:
django-admin.py startproject xxxx
上面这个命令会创建一个 djproject 目录，其中包含了运行 Django 项目所需要的基
本配置文件

要创建应用程序，可以使用 manage.py 脚本，这是一个特定于项目的 django-admin.py 脚本，其中 settings.py 文件可以自动提供

python2 manage.py startapp jobs
这样将要创建一个应用程序骨架，其中模型有一个Python模块，视图有另外一个Python模块
会在job目录下生成__init__.py modules.py views.py

为了使 Django 认识到新应用程序的存在，还需要向 settings.py 文件中的 INSTALLED_APPS 添加一个条目。对于这个职位公告板应用程序来说，我们必须添加字符串 djproject.jobs

Django的404 Error页
这个错误


当我们输入网址的时候，所有均开始与setting文件。当我们运行python manger.py 
runserver,脚本将在于manger.py同一个目录下查找名为setting.py的文件。这个文件
包含了所有有关这个Django项目的配置信息，均大写:TEMPLATE_DIRS, DATABASE_NAME
等。最重要的设置是ROOT_URLCONF，它将作为URLconf告诉Django在这个站点中哪些
python的模块将被用到。
如:mysite.urls ========= mysite/urls.py

当访问我们的urls.py的文件的是哈，Django根据ROOT_URLCONF的设置装载URLconf。然
后按顺序逐个匹配URLconf里面的URLpatterns，直到找到一个匹配的。当找到这个匹配
的URLpatterns就调用相关联的view函数，并把HttpResponse对象作为第一个参数，返
回。


----------------------------------------------------------------------------
	

				动态内容

我们可以在我们views.py文件中加入我们的一些视图函数：
(注意，返回HttpResponse对象)。还不要忘了导入相应的模块。
添加完之后，不要忘了在我们的urls.py文件中，匹配我们的新添加的视图函数

注意：Django是有时区区分的，并且默认时区是America/Chicago。(它必须有个值，
它的默认值是Django的诞生地:美国/芝加哥)如果我们处于其他的时区，需要进行修改
我们在进行创建的时候，要灵活的使用正则表达式


----------------------------------------------------------------------------
			    URL配置和松耦合
松耦合是一个重要的保证互换性的软件开发方法。


出错的调试：
我们可以用过使用assert False来触发出错页面。
Django在我们开启运行服务器的时候，它默认的运行了debug模式.


			      Django模板
将我们的HTML编写到我们的views文件不是一个好的主意。原因如下：
1.对页面设计进行的任何改变都必须对Python代码进行相应的改变。站点设计的修改往
往比底层Python代码的修改要繁琐的多，由此如果可以不再进行Python代码修改的现况
下变更设计，那将会方便得多。

2.Python代码编写和HTML设计是两个不同的工作，大多数专业的网站开发环境都将他们
分配给不同的人员(部门)来完成。设计者和HTML/CSS的编码人员不应该被要求去编辑
Python的代码来完成他们的工作

3.程序员编写Python代码和设计人员制作模板两项工作同时进行的效率是最高。

使用模板：
需要导入模块:from django.template import Template,Contex
这里的Template模块是我们定义模板的模块
Contex模块是我们对模板进行实例化使用的模块
如:
from django.template import Template, Contex

t = Template('Hello , {{ name }}')
t.render(Contex({'name':'songshuang'}))
这样t就是Hello，songshuang了
还可以这样的使用:
c = Context({'name':'songshuang'})
t.render(c)
结果和上面的一样

我们可以用过context不仅可以传递简单的字符串，还可以处理更加复杂的数据结构，
如list,dictionary,和自定义的对象。

在Django模块中遍历复杂数据结构的关键是句点字符(.)
如:
from django.template import Template,Context
person = {'name':'songshuang', 'age':'23'}
t = Template('{{ person.name }} is {{ person.age }} yeras old')
c = Context({'person':person})
t.render(c)



from django.template import Template,Context
import datetime
d = datetime.date(1991,10,15)
d.year ----> 1991
d.month----> 10
d.day  ----> 15

t = Template('The month is {{ date.month }} and the year is {{ date.year}}')
c = Context({'date':d})
t.render(c)


对类进行的模板操作:
from django.tempalte import Template,Context

class Person(object):
	def __init__(self, first_name, last_name):
		self.first_name, self.last_name = first_name, last_name

t = Template('Hell, {{ Person.first_name }}{{ Person.last_name }}')
C = Context({'person':Person('song',shuang)})//进行调用构造函数，进行创建对
象
t.render(C)

点语法也可以用来引用对象的‘方法’。
如:
from django.template import Template,Context
t = Template('{{ var }} -- {{ var.upper }} -- {{ var.idigit }}')
c = Context({'var':'123'})
t.render(c)
注意:这里调用的方法只能是调用没有参数的方法.

句点也可以用与访问列表的索引:
如:
from django.tempalte import Template,Context
t = Template('item 2 is {{ items.2 }}')
c = Context({'items':['apple','bananas','carrots']})
t.render(c)
注意：不允许使用负数表示索引。

方法调用的行为:
在方法查找的过程中，如果某个方法抛出一个异常，除非该异常有一个
silent_variable_failure属性并且值为True,否则的话，它将被传播。如果异常被传播
模板里的变量将变成空白的字符串。

处理无效的变量:
在默认的情况下，如果一个变量不存在，模块系统会把它展示为空字符串，不做任何
事情来表示失败。
如:
from djanfo.tempalte import Template,Context
t = Template('Your name is {{ name }}')
t.render(Context())
这样的话，只会输出Your name is.
系统只是静悄悄的表示失败，而不是抛出一个异常。

标签:
{% if %}标签检查一个变量，如果这个变量为真(几存在)
如:
{% if %}
	...
{% else %}
	...
{% endif%}

在Python和Django的模板系统中，为False的情况:
1.空列表
2.空元组
3.空字典
4.空字符串
5.零值(0)
6.特殊对象None
7.对象False

注意：我们使用if的时候，一定要加上一个endif

{% for... %}
	...
{% endfor %}
用法和if...else...endif一样
注意：Django不支持退出循环操作，也不支持continue。
在我们的for循环中，有个forloop.counter总是一个表示当前循环执行次数的整数计数
器。这个计数器是从1开始计数。
forloop.counter0:从0开始计数
forloop.revcounter:表示循环中剩余的整型变量
forloop.revcounter0:从0开始计数的表示剩余的整型变量
forloop.first:判断是否是第一次执行
如:
{% for object in objects%}
	{% if forloop.first %}
		<li class="first">
	{% else %}
		<li>
	<% endif %>
	{{ object }}
	</li>
{% endfor %}

forloop.last:在最后一次被执行的时候被置为True
如:
{% for link in links%}
	{{ link }}
	{% if not forloop.last %}| {% endif %}
{% endfor %}
上面的结果会产生如下的结果:
link1 | link2 | link3 | link4

注意:在一个{% for %}块中，已经存在的变量会被移除，以避免forloop变量会被覆盖
Django会把这个变量移动到forloop.parentloop中通常我们不用担心这个问题，但是一
旦我们在模块中定义了forloop这个变量，在{%for%}块中它会在forloop.parentloop被
重新命名.

注释:{# ....... #}这种注释的方法不能跨越多行进注释
需要实现多行的注释，我们需要这样的使用:
"{.....}"


过滤器:
过滤器就是我们的管道的使用.
如:
{{ name|upper }}---->显示的变量name是我们大写转换之后的结果
{{ my_list|first|upper }}-->显示的是我们第一个转换成大写之后的结果
有些过滤器有参数的:如:
{{ bio|truncatwords:"30" }}-->这个将显示变量bio的前30个词

比较重要的过滤器:
addslashes:添加反斜刚到任何反斜杠，单引号或者双引号前面。这些处理在JavaScrip
t的文本是非常有用的。
date：按指定的格式字符串参数格式化date或datetime对象。
如:{{ pub_date|date:"F j, Y" }}
length:返回变量的长度。


				模块的自动加载和模块目录技巧
模块加载：
模块的自动加载我们使用的是模块加载API，首先我们必须将这个模板的保存位置告诉
框架。(ROOT_URLCONF的配置settints.py)
TEMPLATE_DIRS=(
	"/home/diango/html/templates",
)

设置完了TEMOLATE_DIRS之后，下一步就是修改试图的代码了
如:
from django.tempalte.loader import get_template

def current_datetime(request):
	now = datetime.datetime.now()
	t = get_template('current_datetime.html')
	html = t.render(Context({'current_date':now}))
	return HttpResponse(html)

我们使用get_template（）加载我们的函数模块。


render_to_response()
需要导入模块:
from django.shortcuts import render_to_response
使用这个方法的话，会省略了我们get_template(),render()
如:
from django.shortcuts import render_to_response
import datetime

def current_datetime(request):
	now = datetime.datetime.now()
	retuen render_to_response('current_datetime.html',{'currrnt_date':now})
render_to_response()的第一个参数必须是要使用的模块名称。如果要给定第二个参数
，那么该参数必须是为该模板创建Context时所需要的字典。如果不传，使用空字典。


				include模板标签

使用include是将我们其他的html模板加载到我们的html程序中
如:
	#mypage.html
<html>
<body>
	{% include "../songshuang.html"%}
<h1>{{ tittle }}</h1>
</body>
</html>

	#songshuang.html
<div id = "nav">
	You are in:{{ current_section }}
</div>



				模板继承

模板继承就是先构造一个基础框架模板，而后在其子模板中对它所包含站点公用部分和
定义块进行重载。
使用过程:
1.定义基础模板，该框架之后由子模板所继承.
<!DOCTYOPE HTML PUBLIC "//w3c//dtd html 4.01//en">
<html lang="en">
<head>
	<title>{% block title%}{% endblock %}</title>
</head>
<body>
	<h1>My helpful timestamp site</h1>
	{% block content%}{% endblock %}
	{% block footber%}
	<hr>
	<p>Thanks for visiting my site</p>
	{% endblock %}
</body>
</html>
所有的{% block %}标签告诉模板引擎，子模板可以重载这些部分。每个{% block %}
标签所要做的是告诉模板引擎，该模板下的这一块内容将有可能被覆盖
下面就是对上面的基本模板进行重载：
#current_datetime.html
....
{% extend "base.html" %}
{% block title %}The Current time{% endblock %}
{% block content%}
<p>it is now {{ current_date }}.</p>
{% endblock %}
....
